
# """Database management module using Kybra Simple DB."""

# from typing import Optional, Dict, List
# from kybra_simple_db import Entity, Database
# from datetime import datetime
# from kybra import ic
# from core.system_time import get_system_time, timestamp_to_datetime

# class TimestampedEntity(Entity):
#     """Base class adding timestamping and ownership functionality."""
    
#     def __init__(self, **kwargs):
#         super().__init__(**kwargs)
#         self.timestamp_created = 0
#         self.timestamp_updated = 0
#         self.owner = None
#         self.creator = None
#         self.updater = None

#     def _update_timestamps(self):
#         """Update timestamps and ownership information before saving."""
#         now = get_system_time()
#         caller = str(ic.caller())
        
#         if not self.timestamp_created:
#             self.timestamp_created = now
#             self.creator = caller
#             self.owner = caller
        
#         if caller != self.owner:
#             raise PermissionError(f"Only the owner can update this entity. Current owner: {self.owner}")
        
#         self.timestamp_updated = now
#         self.updater = caller

#     def save(self) -> 'TimestampedEntity':
#         """Save the entity with updated timestamps."""
#         self._update_timestamps()
#         super().save()
#         return self

#     def set_owner(self, new_owner: str) -> None:
#         """Change the owner of this entity."""
#         if str(ic.caller()) != self.owner:
#             raise PermissionError(f"Only the current owner can transfer ownership")
#         self.owner = new_owner
#         self.save()

#     def to_dict(self) -> dict:
#         """Convert entity to dictionary with timestamp information."""
#         data = super().to_dict()
#         data.update({
#             "timestamp_created": f"{timestamp_to_datetime(self.timestamp_created)} ({self.timestamp_created})",
#             "timestamp_updated": f"{timestamp_to_datetime(self.timestamp_updated)} ({self.timestamp_updated})",
#             "creator": self.creator,
#             "updater": self.updater,
#             "owner": self.owner
#         })
#         return data

# class User(TimestampedEntity):
#     """User entity with timestamp tracking."""
#     _entity_type = "user"

#     def __init__(self, name: str, principal_id: str, **kwargs):
#         super().__init__()
#         self.name = name
#         self.principal_id = principal_id
#         self.created_at = datetime.now().isoformat()
#         self.organizations: List[str] = []
#         for k, v in kwargs.items():
#             setattr(self, k, v)

# class Organization(TimestampedEntity):
#     """Organization entity."""
#     _entity_type = "organization"

#     def __init__(self, name: str, owner_id: str, **kwargs):
#         super().__init__()
#         self.name = name
#         self.owner_id = owner_id
#         self.created_at = datetime.now().isoformat()
#         self.members: List[str] = [owner_id]
#         self.tokens: List[str] = []
#         for k, v in kwargs.items():
#             setattr(self, k, v)

# class Token(TimestampedEntity):
#     """Token entity for tracking token information."""
#     _entity_type = "token"

#     def __init__(self, name: str, symbol: str, organization_id: str, **kwargs):
#         super().__init__()
#         self.name = name
#         self.symbol = symbol
#         self.organization_id = organization_id
#         self.created_at = datetime.now().isoformat()
#         self.total_supply = 0
#         self.holders: Dict[str, int] = {}
#         for k, v in kwargs.items():
#             setattr(self, k, v)

# class Proposal(TimestampedEntity):
#     """Proposal entity for governance."""
#     _entity_type = "proposal"

#     def __init__(self, title: str, description: str, creator_id: str, organization_id: str, **kwargs):
#         super().__init__()
#         self.title = title
#         self.description = description
#         self.creator_id = creator_id
#         self.organization_id = organization_id
#         self.created_at = datetime.now().isoformat()
#         self.status = "active"  # active, passed, rejected
#         self.votes: Dict[str, bool] = {}  # user_id: voted_yes
#         for k, v in kwargs.items():
#             setattr(self, k, v)


# # User operations
# def create_user(name: str, principal_id: str, **kwargs) -> User:
#     """Create a new user."""
#     user = User(name=name, principal_id=principal_id, **kwargs)
#     user.save()
#     return user

# def get_user(user_id: str) -> Optional[User]:
#     """Get a user by ID."""
#     return User.load(entity_id=user_id)

# def get_all_users() -> List[User]:
#     """Get all users."""
#     return User.load_all()

# # Organization operations
# def create_organization(name: str, owner_id: str, **kwargs) -> Organization:
#     """Create a new organization."""
#     org = Organization(name=name, owner_id=owner_id, **kwargs)
#     org.save()
    
#     # Add organization to user's organizations
#     user = get_user(owner_id)
#     if user:
#         user.organizations.append(org.id)
#         user.save()
    
#     return org

# def get_organization(org_id: str) -> Optional[Organization]:
#     """Get an organization by ID."""
#     return Organization.load(entity_id=org_id)

# def get_all_organizations() -> List[Organization]:
#     """Get all organizations."""
#     return Organization.load_all()

# # Token operations
# def create_token(name: str, symbol: str, organization_id: str, **kwargs) -> Token:
#     """Create a new token."""
#     token = Token(name=name, symbol=symbol, organization_id=organization_id, **kwargs)
#     token.save()
    
#     # Add token to organization's tokens
#     org = get_organization(organization_id)
#     if org:
#         org.tokens.append(token.id)
#         org.save()
    
#     return token

# def get_token(token_id: str) -> Optional[Token]:
#     """Get a token by ID."""
#     return Token.load(entity_id=token_id)

# def get_all_tokens() -> List[Token]:
#     """Get all tokens."""
#     return Token.load_all()

# # Proposal operations
# def create_proposal(title: str, description: str, creator_id: str, organization_id: str, **kwargs) -> Proposal:
#     """Create a new proposal."""
#     proposal = Proposal(
#         title=title,
#         description=description,
#         creator_id=creator_id,
#         organization_id=organization_id,
#         **kwargs
#     )
#     proposal.save()
#     return proposal

# def get_proposal(proposal_id: str) -> Optional[Proposal]:
#     """Get a proposal by ID."""
#     return Proposal.load(entity_id=proposal_id)

# def get_all_proposals() -> List[Proposal]:
#     """Get all proposals."""
#     return Proposal.load_all()
